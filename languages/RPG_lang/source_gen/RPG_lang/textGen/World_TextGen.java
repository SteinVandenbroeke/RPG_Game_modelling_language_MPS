package RPG_lang.textGen;

/*Generated by MPS */

import jetbrains.mps.text.rt.TextGenDescriptorBase;
import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.text.impl.TextGenSupport;
import RPG_lang.behavior.World__BehaviorDescriptor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import RPG_lang.behavior.Grid__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import RPG_lang.behavior.Tile__BehaviorDescriptor;
import RPG_lang.behavior.Item__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class World_TextGen extends TextGenDescriptorBase {
  @Override
  public void generateText(final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    tgs.append("# RPG meta model");
    tgs.newLine();
    tgs.append("mm_rpg_def = \"\"\"\n    ### Classes ###\n    Creatures:Class {\n        abstract=True;\n        constraint = ```\n            get_slot_value(this, \"lives\") >= 0\n        ```;\n    }\n    \n    Creatures_lives:AttributeLink (Creatures -> Integer) {\n        name = \"lives\";\n        optional = False;\n    }\n    \n    Hero:Class {\n        lower_cardinality = 1;\n        upper_cardinality = 1;\n    }\n    :Inheritance (Hero -> Creatures)\n    \n    Monster:Class\n    :Inheritance (Monster -> Creatures)\n    \n    Level:Class\n    \n    Level_name:AttributeLink (Level -> String) {\n        name = \"name\";\n        optional = False;\n    }\n    \n    World:Class{\n        lower_cardinality = 1;\n        upper_cardinality = 1;\n    }\n    \n    Tile:Class{\n        abstract=True;\n        constraint = ```\n            no_dubble_directions = True\n            items = set()\n            for tileItem in get_incoming(this, \"TileToTile\"):\n                if get_slot_value(tileItem, \"direction\") in items:\n                    no_dubble_directions = False;\n                items.add(get_slot_value(tileItem, \"direction\"))\n            no_dubble_directions\n        ```;\n    }\n    \n    StandardTile:Class\n    :Inheritance (StandardTile -> Tile)\n    \n    Door:Class\n    :Inheritance (Door -> Tile)\n    \n    Trap:Class\n    :Inheritance (Trap -> Tile)\n    \n    Obstacle:Class\n    :Inheritance (Obstacle -> Tile)\n    \n    Item:Class{\n        abstract=True;\n    }\n    \n    Key:Class {\n        constraint = ```\n            len(get_incoming(this, \"DoorToKey\")) == 1\n        ```;\n    }\n    :Inheritance (Key -> Item)\n    \n    Objective:Class {\n        constraint = ```\n            get_slot_value(this, \"points\") <= 100\n        ```;\n    }\n    :Inheritance (Objective -> Item)\n    \n    Objective_points:AttributeLink (Objective -> Integer) {\n        name = \"points\";\n        optional = False;\n    }\n    \n    ### Attributes ###\n    \n    CreaturesTile:Association (Creatures -> Tile) {\n        target_lower_cardinality = 1;\n        target_upper_cardinality = 1;\n    }\n    \n    WorldToLevel:Association (World -> Level) {\n        target_lower_cardinality = 1;\n    }\n    \n    LevelToTile:Association (Level -> Tile) {\n        target_lower_cardinality = 1;\n        source_upper_cardinality = 1;\n    }\n    \n    TileToTile:Association (Tile -> Tile) {\n        target_upper_cardinality = 4;\n        constraint = ```\n            tile0 = get_source(this)\n            tile1 = get_target(this)\n            \n            get_source(get_incoming(tile0, \"LevelToTile\")[0]) == get_source(get_incoming(tile1, \"LevelToTile\")[0])\n        ```;\n    }\n    \n    TileToTile_direction:AttributeLink (TileToTile -> String) {\n        name = \"direction\";\n        optional = False;\n    }\n    \n    StandardToTileItem:Association (StandardTile -> Item) {\n        target_lower_cardinality = 0;\n        target_upper_cardinality = 1;\n    }\n    \n    DoorToKey:Association (Door -> Key) {\n        target_lower_cardinality = 1;\n        target_upper_cardinality = 1;\n        source_lower_cardinality = 1;\n        source_upper_cardinality = 1;\n    }\n    \n    DoorToDoor:Association (Door -> Door){\n        target_lower_cardinality = 1;\n        target_upper_cardinality = 1;\n        \n        constraint = ```\n            door0 = get_source(this)\n            door1 = get_target(this)\n            \n            DoorLevel0 = get_incoming(door0, \"LevelToTile\")[0]\n            DoorLevel1 = get_incoming(door1, \"LevelToTile\")[0]\n            DoorLevel0 != DoorLevel1\n            ```;\n    }\n    \n    \n    ### Global Constraints ###\n\n\n    AllObjectivesPointsUnder100:GlobalConstraint {\n        constraint = ```\n            total_amount_of_objective_points = 0\n            for _, objective in get_all_instances(\"Objective\"):\n                total_amount_of_objective_points += get_slot_value(objective, \"points\")\n            \n            total_amount_of_objective_points <= 100\n        ```;\n    }\n    \n    AtMostOneMonsterPerLevel:GlobalConstraint {\n        constraint = ```\n            valid_constraint = True\n            monster_levels = []\n            for _, monster in get_all_instances(\"Monster\"):\n                monster_level = get_name(get_source(get_incoming(get_target(get_outgoing(monster, \"CreaturesTile\")[0]), \"LevelToTile\")[0]))\n                if monster_level in monster_levels:\n                    valid_constraint = False\n                    break\n                monster_levels.append(monster_level)\n            \n            valid_constraint\n        ```;\n    }\n\"\"\"\n\n# TODO: add your runtime-meta-model\nrt_mm_rpg_def = mm_rpg_def + \"\"\"\n    Clock:Class {\n        lower_cardinality = 1;\n        upper_cardinality = 1;\n    }\n    \n    Clock_time:AttributeLink (Clock -> Integer) {\n        name = \"time\";\n        optional = False;\n    }\n    \n    State:Class {\n        abstract = True;\n    }\n    \n    WorldState:Class\n    :Inheritance (WorldState -> State)\n    \n    WorldState_collectedpoints:AttributeLink (WorldState -> Integer) {\n        name = \"collectedpoints\";\n        optional = False;\n    }\n    \n    CreatureState:Class\n    :Inheritance (CreatureState -> State)\n    \n    CreatureState_moved:AttributeLink (CreatureState -> Boolean) {\n        name = \"moved\";\n        optional = False;\n    }\n    \n    CreatureState_fought:AttributeLink (CreatureState -> Boolean) {\n        name = \"fought\";\n        optional = False;\n    }\n    \n    \n    \n    # Associations\n    WorldStateToWorld:Association (WorldState -> World) {\n        target_lower_cardinality = 1;\n        target_upper_cardinality = 1;\n    }\n    \n    CreatureStateToCreature:Association (CreatureState -> Creatures) {\n        target_lower_cardinality = 1;\n        target_upper_cardinality = 1;\n    }\n    \n    HeroCollectsItems:Association (Hero -> Item)\n    \n    \n    NoCreatureOnObstacle:GlobalConstraint {\n        constraint = ```\n            valid_constraint = True\n            for _, monster in get_all_instances(\"Monster\"):\n                monster_tile_type = get_type_name(get_target(get_outgoing(monster, \"CreaturesTile\")[0]))\n                valid_constraint = monster_tile_type != \"Obstacle\" and valid_constraint\n            valid_constraint\n        ```;\n    }\n\"\"\"");
    tgs.newLine();
    tgs.newLine();

    tgs.append("# RPG autogenerated model");
    tgs.newLine();
    tgs.append("rt_m_rpg_def = \"\"\"\n");
    String world_name = World__BehaviorDescriptor.getProcessedName_id3ruJhwZEX3Q.invoke(ctx.getPrimaryInput());
    String world_state_name = world_name + "_state";
    tgs.newLine();
    tgs.append(world_name);
    tgs.append(":World");
    tgs.newLine();
    tgs.append(world_state_name);
    tgs.append(":WorldState");
    tgs.append("{");
    tgs.newLine();
    tgs.append("collectedpoints = 0;");
    tgs.newLine();
    tgs.append("}");
    tgs.newLine();
    tgs.append(world_name);
    tgs.append("to_state");
    tgs.append(":WorldStateToWorld");
    tgs.append("(");
    tgs.append(world_state_name);
    tgs.append(" -> ");
    tgs.append(world_name);
    tgs.append(")");
    tgs.newLine();
    tgs.append("C:Clock {time = 0;}");
    tgs.newLine();
    for (SNode item : SLinkOperations.getChildren(ctx.getPrimaryInput(), LINKS.levels$yhqr)) {
      tgs.appendNode(item);
    }
    tgs.newLine();
    tgs.append("#--- connections between doors ---#");
    tgs.newLine();
    for (SNode door : SModelOperations.nodes(SNodeOperations.getModel(ctx.getPrimaryInput()), CONCEPTS.DoorTile$Z4)) {
      // Check for safety if door is on that location of the grid 
      if (Grid__BehaviorDescriptor.getTile_id5cWYGer5xL0.invoke(SNodeOperations.getNodeAncestor(door, CONCEPTS.Grid$OZ, false, false), ((int) SPropertyOperations.getInteger(door, PROPS.rowNr$u_pf)), ((int) SPropertyOperations.getInteger(door, PROPS.colNr$uzx7))) == door) {
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(door));
        tgs.append("_TO_");
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(SLinkOperations.getTarget(door, LINKS.to_door$Lj_Q)));
        tgs.append(":DoorToDoor (");
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(door));
        tgs.append(" -> ");
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(SLinkOperations.getTarget(door, LINKS.to_door$Lj_Q)));
        tgs.append(")");
        tgs.newLine();
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(door));
        tgs.append("_TO_");
        tgs.append(Item__BehaviorDescriptor.getProcessedName_id3ruJhwZl4Yr.invoke(SLinkOperations.getTarget(door, LINKS.needed_key$48$j)));
        tgs.append(":DoorToKey (");
        tgs.append(Tile__BehaviorDescriptor.getProcessedName_id3ruJhwZbBX1.invoke(door));
        tgs.append(" -> ");
        tgs.append(Item__BehaviorDescriptor.getProcessedName_id3ruJhwZl4Yr.invoke(SLinkOperations.getTarget(door, LINKS.needed_key$48$j)));
        tgs.append(")");
        tgs.newLine();
      }
    }
    tgs.newLine();
    tgs.appendNode(SLinkOperations.getTarget(ctx.getPrimaryInput(), LINKS.hero$P5pr));

    tgs.append("\"\"\"");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink levels$yhqr = MetaAdapterFactory.getContainmentLink(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x696b4b7b47a4eb00L, 0x2a240b133398ddL, "levels");
    /*package*/ static final SReferenceLink to_door$Lj_Q = MetaAdapterFactory.getReferenceLink(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x533cfac39a956d98L, 0x533cfac39ab91b34L, "to_door");
    /*package*/ static final SReferenceLink needed_key$48$j = MetaAdapterFactory.getReferenceLink(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x533cfac39a956d98L, 0x533cfac39a956dabL, "needed_key");
    /*package*/ static final SContainmentLink hero$P5pr = MetaAdapterFactory.getContainmentLink(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x696b4b7b47a4eb00L, 0x696b4b7b47a58a0cL, "hero");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Grid$OZ = MetaAdapterFactory.getConcept(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x698935b6d18cac85L, "RPG_lang.structure.Grid");
    /*package*/ static final SConcept DoorTile$Z4 = MetaAdapterFactory.getConcept(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x533cfac39a956d98L, "RPG_lang.structure.DoorTile");
  }

  private static final class PROPS {
    /*package*/ static final SProperty rowNr$u_pf = MetaAdapterFactory.getProperty(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x698935b6d18cac8bL, 0x533cfac39aa9d271L, "rowNr");
    /*package*/ static final SProperty colNr$uzx7 = MetaAdapterFactory.getProperty(0x3ae3bfbd8089435bL, 0xbab31d2f4ee9bb39L, 0x698935b6d18cac8bL, 0x533cfac39aa9d269L, "colNr");
  }
}
